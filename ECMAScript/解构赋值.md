
<!-- toc orderedList:0 -->

- [数组的解构赋值](#数组的解构赋值)
- [对象的解构赋值](#对象的解构赋值)
	- [嵌套的解构赋值](#嵌套的解构赋值)
- [字符串的解构赋值](#字符串的解构赋值)
- [数值和布尔值的解构赋值](#数值和布尔值的解构赋值)
- [函数参数的解构赋值](#函数参数的解构赋值)

<!-- tocstop -->

# 数组的解构赋值

ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。

```js
var a = 1;
var b = 2;
var c = 3;

ES6允许写成下面这样。
var [a, b, c] = [1, 2, 3];
```

这种写法有点像‘模式匹配’，如果匹配不成功就会返回'undefined'。

```js
let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```

如果左边只匹配右边部分值，仍是解构成功。
只要某种数据结构具有`Iterator`接口，都可以采用数组形式的解构赋值。

数组可以使用默认值，只要数组成员不严格等于`undefined`。

# 对象的解构赋值

解构不仅可以用于数组，还可以用于对象。
对象的解构赋值与数组的不同，对象的解构赋值变量必须与属性同名。

```js
var { foo, bar } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"
```

这实际上说明，对象的解构赋值是下面形式的简写：

```js
var { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };
```

对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

```js
var { foo: baz } = { foo: "aaa", bar: "bbb" };
baz // "aaa"
foo // error: foo is not defined
```

`foo`是匹配的模式，`baz`才是变量。真正被赋值的是变量`baz`，而不是模式`foo`。

对象的默认值生效的条件是，对象的属性值严格等于`undefined`。

## 嵌套的解构赋值

```js
var obj = {
  p: [
    'Hello',
    { y: 'World' }
  ]
};

var { p: [x, { y }] } = obj;
x // "Hello"
y // "World"
```
这时p是模式，不是变量，因此不会被赋值。

```js
// 报错
var {foo: {bar}} = {baz: 'baz'};
```

foo这时等于undefined，再取子属性就会报错

# 字符串的解构赋值

字符串被转换成了一个类似数组的对象。

```js
const [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"


let {length : len} = 'hello';
len // 5
```

类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。


# 数值和布尔值的解构赋值

解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
`undefined`和`null`无法转为对象，所以对它们进行解构赋值，都会报错。

```js
let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true

let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
```

# 函数参数的解构赋值

函数的参数也可以使用解构赋值，传入参数的时候就会被解构。

```js
function add([x, y]){
  return x + y;
}

add([1, 2]); // 3
```

>参考[阮一峰的ES6教程](http://es6.ruanyifeng.com/?search=import&x=15&y=8#docs/destructuring)
